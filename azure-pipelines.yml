trigger:
- develop

variables:
   # Agent VM image name
  vmImageName: 'ubuntu-latest'

  buildConfiguration: 'Debug'
  aspnetEnvironment: 'Development'

  solutionName: 'ElGuerre.Items'
  projectName: 'items-api'

  #SONARQUBE
  sonarServiceConnection: 'Sonar Cloud.io'
  sonarProjectName: 'DotNet.ApiRest.BasicTemplate'
  sonarProjectKey: 'DotNet.ApiRest.BasicTemplate'
  sonarProjectVersion: '1.0'
  sonarOrganization: 'juanluelguerre-github'

  # DOCKER
  dockerRegistryServiceConnection: 'elguerreacrServiceConnection'
  dockerRegistryName: 'elguerreacr'
  dockerRepository: $(projectName)
  # yyyymmdd.n
  dockerTag: $(Build.BuildId)

  # AKS
  kubernetesServiceConnection: 'elguerreaksServiceConnection'
  aksNamespace: 'dev'

  helmChartName: $(projectName)

# parameters:  
#   - name: environment
#     displayName: Environment  
#     default: dev
#     values:
#       - dev
#       - int
#       - pre
#   - name: buildConfiguration
#     displayName: Build Configuration
#     default: Debug
#     values:
#       - Debug
#       - Release
#   - name: aspnetEnvironment
#     displayName: AspNet Environmnt
#     default: Development
#     values:
#       - Development
#       - Release

stages:
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildJob
    pool:
      vImage: $(vmImageName)
    steps:
    - task: SonarCloudPrepare@1
      inputs:
        SonarCloud: 'Sonar Cloud.io Service Connection'
        organization: 'juanluelguerre-github'
        scannerMode: 'MSBuild'
        projectKey: 'DotNet.ApiRest.BasicTemplate'
        projectName: 'DotNet.ApiRest.BasicTemplate'
        extraProperties: |
          sonar.language=cs
          sonar.coverageReportPaths=$(Build.SourcesDirectory)/TestResults/Reports/SonarQube.xml
          sonar.exclusions=**/bin/**/*,**/obj/**/*,**/Migrations/**
          sonar.coverage.exclusions=$(Build.SourcesDirectory)/test/**

    - task: DotNetCoreCLI@2
      displayName: 'dotnet build solution'
      inputs:
        projects: 'content/$(solutionName).sln'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet unit tests'
      inputs:
        command: test
        projects: 'content/test/**/*.Tests.csproj'
        arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=Cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/Tests.Cobertura.xml'
      continueOnError: true

    - task: DotNetCoreCLI@2
      displayName: 'dotnet Integration tests'
      inputs:
        command: test
        projects: 'content/test/**/*.IntegrationTests.csproj'
        arguments: '--configuration $(buildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=Cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/IntegrationTests.Cobertura.xml'
      continueOnError: true

    - task: reportgenerator@4
      displayName: ReportGenerator
      inputs:
        reports: '$(Build.SourcesDirectory)/TestResults/Coverage/Tests.Cobertura.xml;$(Build.SourcesDirectory)/TestResults/Coverage/IntegrationTests.Cobertura.xml'
        targetdir: '$(Build.SourcesDirectory)/TestResults/Reports/'
        reporttypes: 'HtmlInline_AzurePipelines;Cobertura;SonarQube'

    - task: PublishTestResults@2
      displayName: 'Publish Test Results *.trx'
      inputs:
        testResultsFormat: XUnit
        testResultsFiles: '**/*.trx'

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/Reports/Cobertura.xml'
        pathToSources: '$(Build.SourcesDirectory)/content/src'
        reportDirectory: '$(Build.SourcesDirectory)/TestResults/Reports/'

    - task: SonarCloudAnalyze@1

    - publish: $(System.DefaultWorkingDirectory)
      displayName: 'Upload files'
      artifact: api

- stage: ConfigureHelm
  displayName: Configue HelmDeploy
  dependsOn: Build
  condition: succeeded()
  jobs:
  - job: ConfigureHelmJob
    pool: 
      vImage: s(vmImageName)
    steps:
      - download: current
        artifact: api      
      #
      # Actual AKS ya includye Helm3 (y por tanto Tiller) !
      #
      - task: HelmInstaller@1
        inputs:
          helmVersionToInstall: 3.1.1

      - task: Bash@3
        displayName: 'Install Tiller'
        inputs:
          targetType: 'inline'
          script: 'helm tiller start-ci'

      - task: Kubernetes@1
        displayName: 'Allow permissions to kubectl Dashboard'
        inputs:
          connectionType: 'Kubernetes Service Connection'
          kubernetesServiceEndpoint: 'elguerreaksServiceConnection'
          command: apply
          arguments: -f $(Pipeline.Workspace)/api/content/k8s/rbac-config.yaml      

- stage: DeploytoDEV
  displayName: Deploy to DEV
  dependsOn: ConfigureHelm
  condition: succeeded()
  jobs:
  - deployment: DeploymentDEVJob
    pool:
      vmImage: $(vmImageName)
    environment: DEV
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: api

          - task: Docker@2
            inputs:
              containerRegistry: $(dockerRegistryServiceConnection)
              repository: $(dockerRepository)
              command: 'buildAndPush'
              Dockerfile: $(Pipeline.Workspace)/api/content/Dockerfile
              tags: | 
                dev
                $(dockerTag)
              arguments: 'ASPNETCORE_ENVIRONMENT=$(aspnetEnvironment)'

          #
          # heml init dont need in v3.x.x
          #
          - task: HelmDeploy@0
            displayName: 'helm init'
            inputs:
              # namesace (by default) -> Kube-system (Cross for all namespaces)
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              useClusterAdmin: true
              command: init
              upgradeTiller: false
              waitForExecution: false
              # arguments: '--client-only'

          - task: HelmDeploy@0
            displayName: 'helm upgrade'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(aksNamespace)
              useClusterAdmin: true
              command: upgrade
              chartType: FilePath
              chartPath: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)'
              # releaseName: '$(environment)-$(projectName)'
              releaseName: '$(projectName)2'
              overrideValues: 'image.repository=$(dockerRegistryName).azurecr.io/$(dockerRepository),image.tag=$(dockerTag)'
              valueFile: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)/values.yaml'
              # recreate: true
              force: true
              arguments: '--version $(dockerTag)'

- stage: DeploytoINT
  displayName: Deploy to INT'
  dependsOn: ConfigureHelm
  condition: succeeded()
  jobs:
  - deployment: DeploymentINTJob
    pool:
      vmImage: $(vmImageName)
    environment: INT
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: api

          - task: Docker@2
            displayName: 'Docker login'
            inputs:
              containerRegistry: 'elguerreacrServiceConnection'
              command: 'login'

          - task: Bash@3
            displayName: 'Create tag - int'
            inputs:
              targetType: 'inline'
              script: |
                docker tag '$(dockerRegistryName).azurecr.io/$(dockerRepository):dev $(dockerRegistryName).azurecr.io/$(dockerRepository):int

          - task: Bash@3
            displayName: 'Push tag - int'
            inputs:
              targetType: 'inline'
              script: |
                docker push $(dockerRegistryName).azurecr.io/$(dockerRepository):int

          - task: HelmDeploy@0
            displayName: 'helm upgrade'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: int
              useClusterAdmin: true
              command: upgrade
              chartType: FilePath
              chartPath: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)'
              # releaseName: '$(environment)-$(projectName)'
              releaseName: '$(projectName)2'
              overrideValues: 'image.repository=$(dockerRegistryName).azurecr.io/$(dockerRepository),image.tag=int'
              valueFile: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)/values.yaml'
              # recreate: true
              force: true
              arguments: '--version $(dockerTag)'