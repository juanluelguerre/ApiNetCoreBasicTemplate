trigger:
- develop

variables:
   # Agent VM image name
  vmImageName: 'ubuntu-latest'

  # Debug | Release
  buildConfiguration: 'Debug'
  ASPNETCORE_ENVIRONMENT: 'Development'
  solutionName: 'ElGuerre.Items'
  # dev | int | pre
  environment: 'dev'
  projectName: 'items-api'

  #SONARQUBE
  sonarServiceConnection: 'Sonar Cloud.io'
  sonarProjectName: 'DotNet.ApiRest.BasicTemplate'
  sonarProjectKey: 'DotNet.ApiRest.BasicTemplate'
  sonarProjectVersion: '1.0'
  sonarOrganization: 'juanluelguerre-github'

  # DOCKER
  dockerRegistryServiceConnection: 'elguerreacrServiceConnection'
  dockerRegistryName: 'elguerreacr'
  dockerRepository: $(environment)-$(projectName)
  # yyyymmdd.n
  dockerTag: $(Build.BuildId)

  # AKS
  kubernetesServiceConnection: 'elguerreaksServiceConnection'
  aksNamespace: 'dev'

  helmChartName: $(projectName)

stages:
- stage: Build
  displayName: Build Stage
  jobs:
  - job: BuildJob
    pool:
      vImage: $(vmImageName)
    steps:

    - task: SonarCloudPrepare@1
      inputs:
        SonarCloud: 'Sonar Cloud.io Service Connection'
        organization: 'juanluelguerre-github'
        scannerMode: 'MSBuild'
        projectKey: 'DotNet.ApiRest.BasicTemplate'
        projectName: 'DotNet.ApiRest.BasicTemplate'
        extraProperties: |
          sonar.language=cs
          sonar.coverageReportPaths=$(Build.SourcesDirectory)/TestResults/Reports/SonarQube.xml
          sonar.exclusions=**/bin/**/*,**/obj/**/*,**/Migrations/**
          sonar.coverage.exclusions=$(Build.SourcesDirectory)/test/**

    - task: DotNetCoreCLI@2
      displayName: 'dotnet build solution'
      inputs:
        projects: 'content/$(solutionName).sln'

    - task: DotNetCoreCLI@2
      displayName: 'dotnet unit tests'
      inputs:
        command: test
        projects: 'content/test/**/*.Tests.csproj'
        arguments: '--configuration $(BuildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=Cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/Tests.Cobertura.xml'
      continueOnError: true

    - task: DotNetCoreCLI@2
      displayName: 'dotnet Integration tests'
      inputs:
        command: test
        projects: 'content/test/**/*.IntegrationTests.csproj'
        arguments: '--configuration $(BuildConfiguration) /p:CollectCoverage=true /p:CoverletOutputFormat=Cobertura /p:CoverletOutput=$(Build.SourcesDirectory)/TestResults/Coverage/IntegrationTests.Cobertura.xml'
      continueOnError: true

    - task: reportgenerator@4
      displayName: ReportGenerator
      inputs:
        reports: '$(Build.SourcesDirectory)/TestResults/Coverage/Tests.Cobertura.xml;$(Build.SourcesDirectory)/TestResults/Coverage/IntegrationTests.Cobertura.xml'
        targetdir: '$(Build.SourcesDirectory)/TestResults/Reports/'
        reporttypes: 'HtmlInline_AzurePipelines;Cobertura;SonarQube'

    - task: PublishTestResults@2
      displayName: 'Publish Test Results *.trx'
      inputs:
        testResultsFormat: XUnit
        testResultsFiles: '**/*.trx'

    - task: PublishCodeCoverageResults@1
      displayName: 'Publish code coverage'
      inputs:
        codeCoverageTool: Cobertura
        summaryFileLocation: '$(Build.SourcesDirectory)/TestResults/Reports/Cobertura.xml'
        pathToSources: '$(Build.SourcesDirectory)/content/src'
        reportDirectory: '$(Build.SourcesDirectory)/TestResults/Reports/'

    - task: SonarCloudAnalyze@1

    - publish: $(System.DefaultWorkingDirectory)
      displayName: 'Upload files'
      artifact: api

- stage: Deploy
  displayName: Build and push stage'
  dependsOn: Build
  condition: succeeded()
  jobs:
  - deployment: DeploymentJob
    pool:
      vmImage: $(vmImageName)
    environment: $(environmentName)
    strategy:
      runOnce:
        deploy:
          steps:
          - download: current
            artifact: api

          - task: Docker@2
            inputs:
              containerRegistry: $(dockerRegistryServiceConnection)
              repository: $(dockerRepository)
              command: 'buildAndPush'
              Dockerfile: $(Pipeline.Workspace)/api/content/Dockerfile
              tags: $(dockerTag)
              arguments: 'ASPNETCORE_ENVIRONMENT=$(ASPNETCORE_ENVIRONMENT)'

          # - task: HelmInstaller@0
          #   displayName: 'Install Helm 2.16.1'
          #   inputs:
          #     helmVersion: 2.16.1
          #     checkLatestHelmVersion: false
          #     kubectlVersion: 1.17.0
          #     checkLatestKubectl: false

          # - task: Bash@3
          #   displayName: 'Install Tiller'
          #   inputs:
          #     targetType: 'inline'
          #     script: |
          #       installedHelm=$(helm plugin list | grep -c tiller)
          #       if [ ${installedHelm}  -eq 0 ]
          #       then
          #           helm plugin install https://github.com/rimusz/helm-tiller
          #       fi

          #
          # Actual AKS ya includye Helm3 (y por tanto Tiller) !
          #
          - task: HelmInstaller@1
            inputs:
              helmVersionToInstall: 3.1.1

          - task: Bash@3
            displayName: 'Install Tiller'
            inputs:
              targetType: 'inline'
              script: 'helm tiller start-ci'

          # - task: Kubernetes@1
          #   displayName: 'Create namespace'
          #   inputs:
          #     connectionType: 'Kubernetes Service Connection'
          #     kubernetesServiceEndpoint: 'elguerreaksServiceConnection'
          #     command: create
          #     arguments: -f $(Pipeline.Workspace)/api/content/k8s/namespace-dev.json

          # - task: Bash@3
          #   inputs:
          #     targetType: 'inline'
          #     script: |
          #       namespace=$(kubectl get namespaces | grep dev)
          #       if [ ${namespace}  -eq 0 ]
          #       then
          #           kubectl apply -f $(Pipeline.Workspace)/api/content/k8s/rbac-config.yaml
          #       fi

          - task: Kubernetes@1
            displayName: 'Allow permissions to kubectl Dashboard'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: 'elguerreaksServiceConnection'
              command: apply
              arguments: -f $(Pipeline.Workspace)/api/content/k8s/rbac-config.yaml

          #
          # heml init dont need in v3.x.x
          #
          # - task: HelmDeploy@0
          #   displayName: 'helm init'
          #   inputs:
          #     # namesace (by default) -> Kube-system (Cross for all namespaces)
          #     connectionType: 'Kubernetes Service Connection'
          #     kubernetesServiceConnection: $(kubernetesServiceConnection)
          #     useClusterAdmin: true
          #     command: init
          #     upgradeTiller: false
          #     waitForExecution: false
          #     # arguments: '--client-only'

          - task: HelmDeploy@0
            displayName: 'helm upgrade'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceConnection: $(kubernetesServiceConnection)
              namespace: $(aksNamespace)
              useClusterAdmin: true
              command: upgrade
              chartType: FilePath
              chartPath: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)'
              releaseName: '$(projectName)'
              overrideValues: 'image.repository=$(dockerRegistryName).azurecr.io/$(dockerRepository),image.tag=$(dockerTag)'
              valueFile: '$(Pipeline.Workspace)/api/content/k8s/helm/$(helmChartName)/values.yaml'
              # recreate: true
              force: true
              arguments: '--version $(dockerTag)'